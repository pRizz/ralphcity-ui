---
phase: 01-cleanup
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/src/constants/index.ts
  - frontend/src/components/ralphtown/PromptInput.tsx
  - frontend/src/data/mockData.ts
  - backend/src/db/mod.rs
  - backend/src/db/models.rs
  - backend/src/error.rs
autonomous: true
user_setup: []

must_haves:
  truths:
    - "mockData.ts file no longer exists in the codebase"
    - "PromptInput component still renders with model selector and quick actions"
    - "DB layer methods return Result types with descriptive error messages on parse failures"
    - "API errors from DB layer include field/value context in JSON response"
    - "Malformed UUIDs in database return 422 with structured error (not 500)"
  artifacts:
    - path: "frontend/src/constants/index.ts"
      provides: "Relocated availableModels and quickActions constants"
      exports: ["availableModels", "quickActions"]
    - path: "backend/src/db/mod.rs"
      provides: "Safe row parsing helpers and error propagation"
      contains: "parse_uuid"
    - path: "backend/src/error.rs"
      provides: "Enhanced AppError with UnprocessableEntity and Conflict variants"
      contains: "UnprocessableEntity"
  key_links:
    - from: "frontend/src/components/ralphtown/PromptInput.tsx"
      to: "frontend/src/constants/index.ts"
      via: "import statement"
      pattern: "from.*@/constants"
    - from: "backend/src/error.rs"
      to: "backend/src/db/mod.rs"
      via: "From<DbError> for AppError"
      pattern: "impl From<DbError>"
---

<objective>
Remove dead code (mockData.ts) and replace .unwrap() calls in the Rust DB layer with proper Result-based error handling.

Purpose: Reduce panic points in production code and improve error surfaces for debugging. This is technical cleanup to reduce tech debt before adding new features.

Output: Cleaner codebase with mockData.ts removed, and DB layer that returns structured errors instead of panicking on malformed data.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-cleanup/01-CONTEXT.md
@.planning/phases/01-cleanup/01-RESEARCH.md
@.planning/codebase/ARCHITECTURE.md

# Key source files
@frontend/src/data/mockData.ts
@frontend/src/components/ralphtown/PromptInput.tsx
@backend/src/db/mod.rs
@backend/src/db/models.rs
@backend/src/error.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Delete mockData.ts after relocating constants</name>
  <files>
    frontend/src/constants/index.ts (create)
    frontend/src/components/ralphtown/PromptInput.tsx (modify)
    frontend/src/data/mockData.ts (delete)
  </files>
  <action>
1. Create `frontend/src/constants/index.ts` with the two constants from mockData.ts:
   - `availableModels`: string array of model names
   - `quickActions`: string array of action strings
   Export both as named exports.

2. Update `frontend/src/components/ralphtown/PromptInput.tsx`:
   - Change import from `@/data/mockData` to `@/constants`
   - Keep same destructured imports: `{ availableModels, quickActions }`

3. Delete `frontend/src/data/mockData.ts` entirely.

4. Verify no other files import from mockData.ts (grep for `mockData` in frontend/src).

Note: The mockRepositories and mockRalphtownInstances are dead code not imported anywhere - they can be deleted along with the file.
  </action>
  <verify>
    - `npm run build` in frontend/ succeeds without errors
    - `grep -r "mockData" frontend/src/` returns no results
    - `ls frontend/src/data/mockData.ts` returns "No such file"
    - `ls frontend/src/constants/index.ts` exists
  </verify>
  <done>
    - mockData.ts file deleted
    - PromptInput imports from @/constants
    - Frontend builds successfully
    - No remaining references to mockData anywhere
  </done>
</task>

<task type="auto">
  <name>Task 2: Replace .unwrap() with proper error handling in DB layer</name>
  <files>
    backend/src/db/models.rs (modify)
    backend/src/db/mod.rs (modify)
    backend/src/error.rs (modify)
  </files>
  <action>
**Step 1: Enhance DbError in db/mod.rs**

Update the DbError enum to add a ParseError variant with structured fields (per CONTEXT.md decisions):

```rust
#[error("Parse error: {message}")]
ParseError {
    message: String,
    value: String,
    field: String,
},
```

**Step 2: Add parsing helpers in db/mod.rs**

Add helper functions before the Database impl:

```rust
/// Parse a UUID from a database row with descriptive error
fn parse_uuid(row: &rusqlite::Row, idx: usize, field: &str) -> rusqlite::Result<Uuid> {
    let value: String = row.get(idx)?;
    Uuid::parse_str(&value).map_err(|e| {
        rusqlite::Error::FromSqlConversionFailure(
            idx,
            rusqlite::types::Type::Text,
            Box::new(DbError::ParseError {
                message: e.to_string(),
                value,
                field: field.to_string(),
            }),
        )
    })
}

/// Parse a DateTime from a database row with descriptive error
fn parse_datetime(row: &rusqlite::Row, idx: usize, field: &str) -> rusqlite::Result<DateTime<Utc>> {
    let value: String = row.get(idx)?;
    chrono::DateTime::parse_from_rfc3339(&value)
        .map(|dt| dt.with_timezone(&Utc))
        .map_err(|e| {
            rusqlite::Error::FromSqlConversionFailure(
                idx,
                rusqlite::types::Type::Text,
                Box::new(DbError::ParseError {
                    message: e.to_string(),
                    value,
                    field: field.to_string(),
                }),
            )
        })
}
```

**Step 3: Update enum from_str methods in models.rs**

Change `SessionStatus::from_str`, `MessageRole::from_str`, and `OutputStream::from_str` to return `Result<Self, String>` instead of `Option<Self>`:

```rust
pub fn from_str(s: &str) -> Result<Self, String> {
    match s {
        "idle" => Ok(SessionStatus::Idle),
        // ... other variants
        _ => Err(format!("invalid session status: '{}'", s)),
    }
}
```

**Step 4: Add enum parsing helper in db/mod.rs**

```rust
/// Parse an enum from a database row with descriptive error
fn parse_enum<T, F>(row: &rusqlite::Row, idx: usize, field: &str, parser: F) -> rusqlite::Result<T>
where
    F: FnOnce(&str) -> Result<T, String>,
{
    let value: String = row.get(idx)?;
    parser(&value).map_err(|e| {
        rusqlite::Error::FromSqlConversionFailure(
            idx,
            rusqlite::types::Type::Text,
            Box::new(DbError::ParseError {
                message: e,
                value,
                field: field.to_string(),
            }),
        )
    })
}
```

**Step 5: Replace all .unwrap() calls in db/mod.rs**

Replace every occurrence like:
```rust
// Before
id: Uuid::parse_str(&row.get::<_, String>(0)?).unwrap(),
created_at: chrono::DateTime::parse_from_rfc3339(&row.get::<_, String>(3)?).unwrap().with_timezone(&Utc),
status: SessionStatus::from_str(&row.get::<_, String>(3)?).unwrap(),

// After
id: parse_uuid(row, 0, "id")?,
created_at: parse_datetime(row, 3, "created_at")?,
status: parse_enum(row, 3, "status", SessionStatus::from_str)?,
```

Apply this to ALL row mapping closures in: get_repo, get_repo_by_path, list_repos, get_session, list_sessions, list_sessions_by_repo, list_messages, list_output_logs (both branches).

**Step 6: Enhance AppError in error.rs**

Add new variants per CONTEXT.md decisions:

```rust
#[derive(Debug)]
pub enum AppError {
    Internal(String),
    NotFound(String),
    BadRequest(String),
    /// Conflict error (409) - e.g., constraint violations
    Conflict(String),
    /// Unprocessable entity (422) - e.g., parse errors
    UnprocessableEntity {
        message: String,
        field: Option<String>,
        value: Option<String>,
    },
}
```

**Step 7: Update IntoResponse for AppError**

Update the JSON response format per CONTEXT.md:

```rust
#[derive(Serialize)]
struct ErrorResponse {
    error: ErrorBody,
}

#[derive(Serialize)]
struct ErrorBody {
    code: String,
    message: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    details: Option<serde_json::Value>,
}
```

Map each variant to appropriate status code and structured response:
- NotFound -> 404, code: "NOT_FOUND"
- BadRequest -> 400, code: "BAD_REQUEST"
- Conflict -> 409, code: "CONFLICT"
- UnprocessableEntity -> 422, code: "PARSE_ERROR", include field/value in details
- Internal -> 500, code: "INTERNAL_ERROR", log the error

**Step 8: Update From<DbError> for AppError**

Add implementation (in error.rs or as separate impl):

```rust
impl From<DbError> for AppError {
    fn from(err: DbError) -> Self {
        match err {
            DbError::NotFound => AppError::NotFound("Resource not found".to_string()),
            DbError::ParseError { message, value, field } => AppError::UnprocessableEntity {
                message,
                field: Some(field),
                value: Some(value),
            },
            other => AppError::Internal(other.to_string()),
        }
    }
}
```

Note: This requires importing DbError in error.rs. Add `use crate::db::DbError;` and ensure no circular dependency (db module imports error for AppError? No - db only has DbError, which is fine).

**Important:** Only log unexpected errors (Internal). NotFound is normal flow, don't log.
  </action>
  <verify>
    - `cargo build` succeeds in backend/
    - `cargo test` passes all existing tests
    - `cargo clippy` shows no new warnings for unwrap usage
    - Manual test: Corrupt a UUID in database, call API endpoint, verify 422 response with structured error (not panic/500)
  </verify>
  <done>
    - No .unwrap() calls remain in db/mod.rs row mapping code (tests are OK to use unwrap)
    - DbError::ParseError variant exists with message, value, field
    - AppError has UnprocessableEntity and Conflict variants
    - AppError IntoResponse returns structured JSON: {"error": {"code": "...", "message": "...", "details": {...}}}
    - Parse failures return 422 with field/value context
    - All existing tests pass
  </done>
</task>

</tasks>

<verification>
Phase-level verification after both tasks complete:

1. **Frontend builds:** `cd frontend && npm run build` exits 0
2. **Backend builds:** `cd backend && cargo build` exits 0
3. **Backend tests pass:** `cd backend && cargo test` exits 0
4. **No mockData references:** `grep -r "mockData" frontend/src/` returns empty
5. **No remaining .unwrap in DB row parsing:** `grep -n "\.unwrap()" backend/src/db/mod.rs` shows only test code or non-row-parsing uses
6. **Error response format:** Start backend, make request that triggers parse error, verify JSON structure matches spec
</verification>

<success_criteria>
- [ ] mockData.ts file deleted from codebase
- [ ] PromptInput component works with constants from @/constants
- [ ] Frontend builds without errors
- [ ] Backend builds without errors
- [ ] All backend tests pass
- [ ] DB layer returns DbError::ParseError on malformed data (not panic)
- [ ] API returns 422 with structured JSON for parse errors
- [ ] API returns 409 for constraint violations (Conflict variant exists)
</success_criteria>

<output>
After completion, create `.planning/phases/01-cleanup/01-01-SUMMARY.md` documenting:
- What was changed
- Key decisions made
- Any deviations from plan
- Files modified
- Tests added/modified
</output>
